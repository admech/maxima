/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 15.04.0 ] */

/* [wxMaxima: input   start ] */
load("helper.mac");
ratprint: false $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Отличия от уравнений без роликов
   [wxMaxima: title   end   ] */

/* [wxMaxima: comment start ]
Покажем, что уравнения для системы с роликами отличаются от уравнений без роликов
аддитивным членом порядка момента инерции ролика в правой части (до разрешений относительно псевдоскоростей):
M* Dnu = f(nu, chi) + B*g(nu, chi)
   [wxMaxima: comment end   ] */

/* [wxMaxima: section start ]
Приготовления
   [wxMaxima: section end   ] */

/* [wxMaxima: subsect start ]
Уравнения без роликов и с роликами
   [wxMaxima: subsect end   ] */

/* [wxMaxima: fold    start ] */

/* [wxMaxima: input   start ] */
batchload("6_eqs_struct_no_rollers.wxm") ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
batchload("5_eqs_struct.wxm") ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: subsect start ]
Вспомогательные функции
   [wxMaxima: subsect end   ] */

/* [wxMaxima: input   start ] */
rho(i) := l*cos(q[3 + i]) - r $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
free_wheel_num(s) := floor((s - 1)/(n_rollers - 1)) $
free_roller_num(s) := mod(s - 1, n_rollers - 1) + 2 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
subst_chis_and_kappas(expr) := expr where append(
    makelist(chi[i] = q[3 + i], i, 1, N_wheels),
    makelist((chi + kappa)[s] = q[3+free_wheel_num(s)] + kappa[free_roller_num(s)], s, 4, dof),
    makelist(chi[s] = q[3+free_wheel_num(s)], s, 4, dof)
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
checkable(expr) := ev(
    ev(expr, sum) where [ 
        subst_chis_and_kappas
    ]
, nouns) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
/* so that we could diff exprs of i and s */
for var in [
    chii,
    kappa_chi_s,
    chi,
    rho,
    nu,
    nu_s
] do depends(var, t) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
diffable(expr) := expr where [ 
    'rho(i) = l*cos(chi[i]) - r,
    chi[i] = chii,
    (kappa + chi)[s] = kappa_chi_s
] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
do_diff(expr) := diff(
        expr where [
            'rho(i) = rho[i],
            'nu[s] = nu_s[s],
            (kappa + chi)[s] = kappa[s] + chi[s]
        ]
    , t) where [ 
    rho[i] = 'rho(i),
    nu_s[s] = 'nu[s],
    kappa[s] + chi[s] = (kappa + chi)[s]
] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
summable(expr) := expr where [ chii = 'q[3 + i] ] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
do_check(original, pretty) := (checkable(pretty) - original) where [ expand, ratsimp ] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
compare_terms(pretty, original) := lsum(term, term, map(factor, 
    expr_to_terms(expand(
        checkable(summable(
            pretty
        ))
    ))
))
-
lsum(term, term, map(factor, 
    expr_to_terms(
        original
    )
)) 
$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
ok_or_error(expected, actual, difference) := if actual = expected then "OK" else error(concat("PRETTY IS NOT EQUAL TO ORIGINAL! DIFF = ", difference(actual))) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
zero_or_error(actual) := ok_or_error(0, actual, lambda([expr], expr)) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
check(original, pretty) := ok_or_error(0, do_check(original, pretty), lambda([expr], expr)) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
check123(original, pretty) := block([result],
    result: makelist(do_check(original[i], pretty[i]), i, 1, 3),
    ok_or_error(makelist(0, i, 1, 3), result, simplode(result, ", "))
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
expr_to_terms(expr) := block([terms],
    terms: [],
    for term in expr do terms: cons(term, terms),
    terms
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Левая часть - d/dt(dL* / dnu)
   [wxMaxima: section end   ] */

/* [wxMaxima: subsect start ]
dL*
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
Лагранжиан со связями, как и кинетическая энергия, отличается от оного системы без роликов лишь аддитивным членом,
пропорциональным моменту инерции ролика относительно оси его собственного вращения:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
L_star_diff: (L_star - old_L_star) where [ expand ] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
разность пропорциональна B:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
is(L_star_diff = (coeff(L_star_diff, B) * B) where [ expand ]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
запишем наглядно:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
/*
for i:1 thru dof do
    for j:i thru dof do
        block([coe],
            coe: (diff(diff(L_star_diff where [ expand ], nu[i]), nu[j]) / (if i = j then 2 else 1)) where [ expand ],
            if not coe = 0 then print(nu[i]*nu[j] = coe)
        ) ;
*/

L_star_diff_pretty: B/2 * (
    'nu[1]^2 * 'sum(R^2*cos(alpha[i])^2/'rho(i)^2, i, 1, N_wheels) + 
    'nu[2]^2 * 'sum(R^2*sin(alpha[i])^2/'rho(i)^2, i, 1, N_wheels) +
    'sum(2*cos(alpha[i])*sin(alpha[i])*'nu[1]*'nu[2]*R^2/'rho(i)^2, i, 1, N_wheels) +
    'sum(2*(sin(alpha[i])*'nu[2] + cos(alpha[i])*'nu[1])*sin(chi[i] + kappa[1])*'nu[3]*R/(Lambda*'rho(i)), i, 1, N_wheels) +
    'nu[3]*'sum(2*'nu[s]*sin((chi+kappa)[s])/Lambda, s, 4, dof) +
    'sum('nu[s]^2, s, 4, dof)
) $
"L*_rollers - L*_old" = L_star_diff_pretty;
"where s corresponds to free rollers and (kappa + chi)[s] means kappa[j] + chi[i] for i = 1..N_wheels, j = 2..n_rollers";
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
check(L_star_diff, L_star_diff_pretty);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
dL* / dnu
   [wxMaxima: subsect end   ] */

/* [wxMaxima: input   start ] */
D_L_star_dnus: makelist(diff(L_star_diff, nu[i]), i, 1, dof) $
/*
for i:1 thru dof do print(concat("dL* / dnu[", i, "] = "), D_L_star_dnus[i]) $
*/
print() $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
D_L_star_dnus_pretty: B * [
    'sum(cos(alpha[i])^2*nu[1]*R^2/'rho(i)^2 + cos(alpha[i])*sin(alpha[i])*nu[2]*R^2/'rho(i)^2 + cos(alpha[i])*sin(chi[i] + kappa[1])*nu[3]*R/('rho(i)*Lambda), i, 1, 3),
    'sum(sin(alpha[i])^2*nu[2]*R^2/'rho(i)^2 + cos(alpha[i])*sin(alpha[i])*nu[1]*R^2/'rho(i)^2 + sin(alpha[i])*sin(chi[i] + kappa[1])*nu[3]*R/('rho(i)*Lambda), i, 1, 3),
    'sum((sin(alpha[i])*nu[2] + cos(alpha[i])*nu[1])*sin(chi[i] + kappa[1])*R/('rho(i)*Lambda), i, 1, 3) + 'sum((sin((chi+kappa)[s])*'nu[s])/Lambda, s, 4, dof),
    'nu[s] + sin((chi+kappa)[s])*nu[3]/Lambda
] $
for i:1 thru 3 do print(concat("dL* / dnu[", i, "] = "), D_L_star_dnus_pretty[i]) $
print(concat("dL* / dnu[s] = "), D_L_star_dnus_pretty[4]) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
check123(D_L_star_dnus, D_L_star_dnus_pretty);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
d/dt(dL* / dnu)
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
Человеческие выражения:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Ddt_D_L_star_dnus_pretty: [
    do_diff(D_L_star_dnus_pretty[1]),
    do_diff(D_L_star_dnus_pretty[2]),
    do_diff(D_L_star_dnus_pretty[3]),
    do_diff(D_L_star_dnus_pretty[4])
] $
for i:1 thru 3 do print(concat("d/dt(dL* / dnu[", i, "]) = "), Ddt_D_L_star_dnus_pretty[i]) $
print(concat("d/dt(dL* / dnu[s]) = "), Ddt_D_L_star_dnus_pretty[4]) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Машинные выражения:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Ddt_D_L_star_dnus: diff(D_L_star_dnus, t) $
/*
for i:1 thru dof do print(concat("d/dt(dL* / dnu[", i, "]) = "), Ddt_D_L_star_dnus[i]) $
*/
print() $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
сравнение:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
for i:1 thru 3 do print(zero_or_error(compare_terms(Ddt_D_L_star_dnus_pretty[i], Ddt_D_L_star_dnus[i]))) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
for i:4 thru dof do print(zero_or_error(compare_terms(Ddt_D_L_star_dnus_pretty[4] where [ s = i ], Ddt_D_L_star_dnus[i]))) $
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
