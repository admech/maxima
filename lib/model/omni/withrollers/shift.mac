require@logging() $
require@wheelutil() $
require@omni_with_rollers_params() $
require@omni_with_rollers_symbols() $

init() := block(

	shlog: get_logger("shifting", log_level_info), 

	permut_list(l, perm) := makelist(l[i], i, perm),
	lshift(l) := permut_list(l, endcons(1, makelist(i, i, 2, length(l)))),
	rshift(l) := permut_list(l, cons(length(l), makelist(i, i, 1, length(l) - 1))),

	shift_vars_on_wheel(vars_on_wheel, chi, override_first, override_last) := block(
		[ shifted_vars ],
		shlog@info("is this wheel switching? chi =", chi, "chi_max =", float(_chi_max_adjust)),
		if chi > _chi_max_adjust then (
		    shlog@info("wheel rotates counter-clockwise, therefore the freed-up roller will have #=1, others shifted forward, last - dropped."),
		    shifted_vars: rshift(vars_on_wheel),
		    shifted_vars[1]: override_first(shifted_vars[1])
		) else if chi < -_chi_max_adjust then (
		    shlog@info("wheel rotates clockwise, therefore the freed-up roller will have #=n, others shifted backward, first - dropped."),
		    shifted_vars: lshift(vars_on_wheel),
		    shifted_vars[length(shifted_vars)]: override_last(shifted_vars[length(shifted_vars)])
		) else (
		    shlog@info("this wheel is not switching"),
		    shifted_vars: vars_on_wheel
		),
		shifted_vars
	),
	calculate_speeds_of_rollers_in_contact(coords) := perwheel(dphi1(i, coords), i),
	calculate_angles_of_rollers_in_contact(coords) := perwheel(extract_phi(i, 1, coords), i),
	defstruct(WhatToShift(
		name,
		contact_values,
		wheel_splitter,
		override_first,
		override_last
	)),
	rollers() := new(WhatToShift(
		"ROLLERS", calculate_speeds_of_rollers_in_contact, split_to_wheels,
		/* set the provided value to the freed roller after shifting */
		[ speed_of_roller_in_contact ] -> buildq([speed_of_roller_in_contact], [nu_edge] -> speed_of_roller_in_contact),
		[ speed_of_roller_in_contact ] -> buildq([speed_of_roller_in_contact], [nu_edge] -> speed_of_roller_in_contact)
	)),
	/* don't want to track the angle of the roller in contact - just start with zero every time */
	phis()    := new(WhatToShift(
		"PHIS",    calculate_angles_of_rollers_in_contact /* not needed though */, split_all_to_wheels,
		/* just keep phis as is after shifting */
		[ not_used ] -> ([phi_edge] -> phi_edge),
		[ not_used ] -> ([phi_edge] -> phi_edge)
	)), 
	shift_vars(what_to_shift, coords) ::= buildq([what_to_shift, coords], [vars] -> block(
		[ wheels, chis, contact_values, result ],
		shlog@info("shifting", what_to_shift@name),
		wheels: what_to_shift@wheel_splitter(vars),
		chis: extract_chis(coords),
		contact_values: what_to_shift@contact_values(coords),
		lreduce(append, perwheel((
			shlog@info("considering wheel #", i),
			shlog@info("was:", wheels[i]),
			result: map(ev, shift_vars_on_wheel(
				wheels[i], chis[i], 
				what_to_shift@override_first(contact_values[i]), what_to_shift@override_last(contact_values[i])
			)),
			shlog@info("will be:", result),
			result
		), i))
	)),

	adjust(chi) := mod(chi - _chi_max_adjust, 2*_chi_max_adjust) - _chi_max_adjust,
	adjust_chis(chis) := map(adjust, chis)

) $