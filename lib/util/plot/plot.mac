init() := block(
	[
		log : get_logger("plot", log_level_info),
		plot_to_terminal
	],
	
	defstruct(
		Plot( /* different options how to show */
			devnull,
			list,
			windows,
			console
		)
	),
	plot : new(Plot),

	defstruct(
		Output(
			name, /* printed to log at pipeline launch */
			show  /* [sol, plot_vars] -> < present visually > */
		)
	),

	defstruct(
		PlotVar(
			name, /* shown in legend */
			get   /* [p] -> [ absciss, ordinate ] */
		)
	),

	plot@devnull : new(Output(
		"sending to /dev/null",
		buildq([log],
			lambda([sol, plot_vars],
				log@info("plot > /dev/null")
			)
		)
	)),

	plot@list : new(Output(
		"listing the solution into the console",
		buildq([log],
			lambda([sol, plot_vars],
				block(
					log@info("Solution:"),
					for p in sol do log@info(p),
					log@info("End of solution.")
				)
			)
		)
	)),

	plot@windows : new(Output(
		"plotting in windows",
		buildq([log],
			lambda([sol, plot_vars],
				block(
					log@info("Gnuplotting to QT window..."),
					plot_to_terminal(
						sol, plot_vars,
						[ gnuplot_preamble, "set terminal qt persist" ]
					)
				)
			)
		)
	)),

	plot@console : new(Output(
		"plotting in the console",
		buildq([log],
			lambda([sol, plot_vars],
				block(
					log@info("Gnuplotting to console..."),
					plot_to_terminal(
						sol, plot_vars,
						[ gnuplot_term, dumb ]
					)
				)
			)
		)
	)),

	plot_to_terminal(sol, plot_vars, terminal) := plot2d (
		makelist(
			[ discrete, makelist(var@get(p), p, sol) ],
			var, plot_vars
		),
		cons(
			legend,
			makelist(var@name, var, plot_vars)
		),
		terminal
	)

) $