require@logging() $
require@file() $

init() := block(
	[
		log : get_logger("plot", log_level_info)
	],

	defstruct(
		Plot( /* different ways of showing */
			devnull,
			list,
			windows,
			console,
			files_in,
			dumping_points_to_file_in,
			these
		)
	),
	plot : new(Plot),

	defstruct( /* a way of showing */
		Output(
			name, /* printed to log at pipeline launch */
			show  /* [sol, plot_groups] -> < present visually > */
		)
	),

	defstruct( /* a figure */
		PlotGroup(
			name,         /* plot title */
			vars,         /* list of PlotVars */
			postamble,    /* e.g. scale axes equally */
			xy_labels,    /* [ xlabel, ylabel ] */
			post_process  /* [ [[ax1,ay1], [ax2,ay2], ...], ... ] -> <same> ; e.g. restore omni rollers' shifts */
		)
	),

	defstruct( /* a line on a figure */
		PlotVar(
			name, /* shown in legend */
			get   /* [p] -> [ absciss, ordinate ] */
		)
	),

	/* show nothing */
	plot@devnull : new(Output(
		"sending to /dev/null",
		buildq([log],
			lambda([sol, plot_groups],
				log@info("plot > /dev/null")
			)
		)
	)),

	/* print all points of the solution */
	plot@list : new(Output(
		"listing the solution into the console",
		buildq([log],
			lambda([sol, plot_groups],
				block(
					log@info("Solution:"),
					for p in sol do log@info(p),
					log@info("End of solution.")
				)
			)
		)
	)),

	/* QT windows */
	plot@windows : new(Output(
		"plotting in windows",
		buildq([log],
			lambda([sol, plot_groups],
				plot_groups_separately(
					"Gnuplotting to QT windows...",
					window_term,
					plot_groups
				)
			)
		)
	)),
	window_num : 0,
	next_window_num() := (window_num: window_num + 1),
	window_term(group) := 
		[ gnuplot_term, sconcat("qt ", next_window_num(), " persist title '", group@name, "'") ]
	,

	/* ASCII art in the console */
	plot@console : new(Output(
		"plotting in the console",
		buildq([log, console_term],
			lambda([sol, plot_groups],
				plot_groups_separately(
					"Gnuplotting to console...", 
					console_term,
					plot_groups
				)
			)
		)
	)),
	console_term(group) := [ gnuplot_term, dumb ],

	/* file */
	file_term(target_dir) := buildq([target_dir], lambda([group], block([target_file],
		target_file : concat(target_dir, "/", group@name, ".eps"),
		log@info("[ plot ] Will plot to", target_file),
		set_plot_option([gnuplot_out_file, target_file]),
		[ gnuplot_term, ps ]
	))),
	plot@files_in : buildq([target_dir, file_term], lambda([target_dir], new(Output(
		"plotting to files",
		buildq([log, target_dir],
			lambda([sol, plot_groups],
				plot_groups_separately(
					"Gnuplotting to files...", 
					file_term(target_dir),
					plot_groups
				)
			)
		)
	)))),

	/* dump points to file */
	plot@dumping_points_to_file_in : lambda([target_dir],
		target_file : concat(target_dir, "/sol.dat"),
		new(Output(
			"dumping points to a file",
			buildq([log, target_dir],
				lambda([sol, plot_groups],
					dump_points_for_all_groups(
						"Dumping points to a file...", 
						target_file,
						plot_groups
					)
				)
			)
		))
	),

	/* do several types of plot */
	plot@these : lambda([types_of_plot], new(Output(
		"doing several plots...",
		buildq([types_of_plot],
			lambda([sol, plot_groups],
				for type_of_plot in types_of_plot do (
					log@info("Plotting by", type_of_plot@name),
					type_of_plot@show(sol, plot_groups)
				)
			)
		)
	))),

	/*
		FUNTIONS THAT DO THE ACTUAL PLOTTING
	*/

	/* one by one */

	plot_groups_separately(msg, term, plot_groups) := block([teh_term],
		log@info(msg),
		for group in plot_groups do (
			teh_term: term(group),
			plot_one_group_to_terminal(
				sol,
				teh_term,
				group
			)
		)
	),

	plot_one_group_to_terminal : buildq([log], lambda([sol, terminal, group],
		log@debug(terminal[2], group@vars),
		log@info("Plotting", group@name, ":", rreduce(sconcat, rest(rreduce(append, makelist([var@name, ", "], var, group@vars)), -1))),
		log@info("Calculating data points..."),
		series_of_2d_points: makelist(
			makelist(var@get(p), p, sol),
			var, group@vars
		),
		log@info("Done calculating data points."),
		log@info("Post-processing..."),
		post_processed_series_of_2d_points: group@post_process(series_of_2d_points),
		log@info("Done post-processing."),
		legend_to_show: cons(
				legend,
				makelist(var@name, var, group@vars)
		),
		log@info("Outputting..."),
		plot2d (
			map([series] -> [ discrete, series ], post_processed_series_of_2d_points),
			legend_to_show,
			[plot_format, gnuplot],
			terminal,
			group@postamble,
			[ xlabel, group@xy_labels[1] ],
			[ ylabel, group@xy_labels[2] ]
		),
		log@info("Done plotting.")
	)),

	/* all together */

	dump_points_for_all_groups(msg, file, plot_groups) := block([teh_term, zipped_ordinates],
		log@info(msg),
		zipped_ordinates : post_process_all_groups(sol, plot_groups),
		dump_list_of_lists_to_file(
			zipped_ordinates,
			file
		)
	),

	post_process_all_groups : buildq([log], lambda([sol, groups],
		groups : sort(groups, [a, b] -> (orderlessp(a@name, b@name))),
		log@info("Group names: ", map([group] -> (group@name), groups)),
		post_processed_zipped_ordinates_of_groups : map(
			[group] -> (
				log@info("Preparing ", group@name, ":", rreduce(sconcat, rest(rreduce(append, makelist([var@name, ", "], var, group@vars)), -1))),
				log@info("Calculating data points..."),
				series_of_2d_points: makelist(
					makelist(var@get(p), p, sol),
					var, group@vars
				),
				log@info("Done calculating data points."),
				log@info("Post-processing..."),
				/* [ [[ax1,ay1], [ax2,ay2], ...], ... ] */
				post_processed_series_of_2d_points: group@post_process(series_of_2d_points),
				log@info("Done post-processing."),
				log@info("Removing absciss..."),
				/* [ [ay1, ay2, ...], ... ] */
				post_processed_series_of_ordinates: map(
					[series] -> ( map(second, series) ),
					post_processed_series_of_2d_points
				),
				log@info("Done removing absciss."),
				log@info("Extracting time points from first series..."),
				post_processed_time_points: map(
					first,
					first(post_processed_series_of_2d_points)
				),
				log@info("Done extracting time points from first series."),
				log@info("Zipping ordinates..."),
				/* [ [ay1, by1, cy1, ...], [ay2, by2, cy2, ...], ... ] */
				zipped_series_of_ordinates: makelist(
					cons(
						post_processed_time_points[pt_idx],
						makelist(
							post_processed_series_of_ordinates[series_idx][pt_idx],
							series_idx, 1, length(post_processed_series_of_ordinates)
						)
					),
					pt_idx, 1, length(first(post_processed_series_of_ordinates))
				),
				log@info("Done zipping ordinates."),
				names_of_ordinates : cons("t", makelist(var@name, var, group@vars)),
				cons(names_of_ordinates, zipped_series_of_ordinates)
			),
			groups
		),
		log@info("Received something of sizes: ",
			length(post_processed_zipped_ordinates_of_groups),
			length(first(post_processed_zipped_ordinates_of_groups)),
			length(first(first(post_processed_zipped_ordinates_of_groups)))
		),
		log@info("Zipping ordinates of all groups..."),
		zipped_ordinates_of_all_groups : makelist(
			lreduce(
				append, 
				makelist(
					if group_idx = 1 then (
						post_processed_zipped_ordinates_of_groups[group_idx][pt_idx]
					) else (
						rest(post_processed_zipped_ordinates_of_groups[group_idx][pt_idx], 1)
					),
					group_idx, 1, length(post_processed_zipped_ordinates_of_groups)
				)
			),
			pt_idx, 1, length(first(post_processed_zipped_ordinates_of_groups))
		),
		log@info("Done zipping ordinates of all groups."),
		zipped_ordinates_of_all_groups
	)),

	dump_list_of_lists_to_file : buildq([log], lambda([list_of_lists, file],
		log@info("Dumping things to file ", file),
		linel_bak : linel,
		linel : 100500,
		with_stdout(
			file,
			for string_line in makelist(
				rreduce(
					sconcat,
					flatten(
						makelist([float(elem), tab], elem, line)
					)
				),
				line, list_of_lists
			) do print(string_line)
		),
		linel : linel_bak,
		log@info("Done dumping.")
	)),

	/* POSTAMBLES */
	no_postamble : [ gnuplot_postamble, "" ],
	equal_axes   : [ gnuplot_postamble, "set size ratio -1;" ]

) $