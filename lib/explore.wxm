/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 15.04.0 ] */

/* [wxMaxima: title   start ]
Process calculated solutions
   [wxMaxima: title   end   ] */

/* [wxMaxima: input   start ] */
for sol_name in [

    "sqrt_no_5_rollers_t_100_self_rot",
    "sqrt_no_5_rollers_t_100_straight",
    "sqrt_no_5_rollers_t_100_wrench"

] do (
    max_t:25 ,

    sol_dir: sol_name,

    batchload("explore.mac") ,
    load_gcp_sol_on_local(sol_name) ,
    
    sol: makelist(sol[i], i, 1, max_t*1000) ,
    
    plotter: plot_to_files ,
    
    show(sol, "trajectory") ,
    show(sol, "theta") ,
    show(sol, "speed_of_mass_center") ,
    show(sol, "nu3") ,
    show(sol, "kin_en") ,
    show(sol, "wheel_angles") ,
    show(sol, "coords") ,

    if not(ssearch("with", sol_name) = false) then (
        for i:1 thru params@N_wheels do show(sol, concat("all_rollers_angles[", i, "]")) ,
        for i:1 thru params@N_wheels do show(sol, concat("all_rollers_speeds[", i, "]"))
    ),

    kill(all)

) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Explore
   [wxMaxima: title   end   ] */

/* [wxMaxima: input   start ] */
sol_dir:NONE;
batchload("explore.mac");
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
use_default_simulation_parameters() $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
use_simulation_parameters_from_dir("/Users/data/Yandex.Disk/work/aspa/zobova/maxima/gcp_sol/simple_with_4_rollers_t_100_diagonal_lo_def") $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
require@omni_with_rollers() $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
derivabbrev:true;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
BELOW HERE GOETH EXPLORATION; ABOVE HERE -- NECESSARY INFRASTRUCTURE
   [wxMaxima: title   end   ] */

/* [wxMaxima: title   start ]
LOOKING FOR INVARIANT SETS
   [wxMaxima: title   end   ] */

/* [wxMaxima: fold    start ] */

/* [wxMaxima: comment start ]
L* - интеграл энергии
dL*/dnu[s] - циклические интегралы (и похоже, они же - интегралы Нётер)

С одной стороны, можно искать (nu, chi), доставляющие критические значения L* просто методом Лагранжа:
W(nu, chi, lambda) = L* + (lambda, dL*/dnu[s] - c),

а с другой, можно через эффективный потенциал (правда ранг матрицы K интегралов dL*/dnu[s] = K(chi)^T nu[s] зависит от chi и может не быть максимальным иногда):
V(chi) = 0 + 1/2 c^T . (K^T . M* . K)^(-1) . c.

Попробуем и так, и эдак.
   [wxMaxima: comment end   ] */

/* [wxMaxima: section start ]
Так: просто методом Лагранжа
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
Выразим lambda и nu через chi и c.
Потом зададим осмысленные значения c.
Потом попытаемся понять, какие chi подходят под это дело.
   [wxMaxima: comment end   ] */

/* [wxMaxima: subsect start ]
util
   [wxMaxima: subsect end   ] */

/* [wxMaxima: input   start ] */
wheel_ind(s) := floor((s - 1) / params@N_wheels) + 1;
pers(wheel_ind(s), s);
roller_ind(s) := mod((s - 1), (params@n_rollers - 1)) + 1 /*skip the one in contact*/ + 1 /*make indexing go from 1*/;
pers(roller_ind(s), s);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
real stuff
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
из dW/dnu[s] и вида линейных интегралов:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
lmbd(s, c) := -c[s]/B;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nu_s(s, c) := -lambda(s, c) - sin(chi[wheel_ind(s)] + kappa[roller_ind(s)]) / Lambda * nu[3];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
поскольку линейные интегралы - интегралы, то dW/dnu = dL*/dnu
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
... не понятно знает, что там, и похоже, через эфф. пот. проще будет.
   [wxMaxima: comment end   ] */

/* [wxMaxima: section start ]
Эдак: через эфф. потенциал, как будто это интегралы Нётер
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
нужна матрица интегралов K(chi):
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
K : transpose(genmatrix(lambda([i,j], diff(diff(L_star, nu[i + 3]), nu[j])), len_nu - 3, len_nu));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
сам потенциал:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
c : pers(c[s], s);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_V_pot_noinvert : transpose(K) . _M_star_inverse . K $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
матрица диагональна!
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
for idxs in lreduce(append, pers(pers([i, j], j), i)) do if not(_V_pot_noinvert[idxs[1]][idxs[2]] = 0) then (print(idxs), print(""), print(_V_pot_noinvert[idxs[1]][idxs[2]]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_V_pot : genmatrix(lambda([i,j], if _V_pot_noinvert[i][j] = 0 then 0 else 1/_V_pot_noinvert[i][j] ), len_nu - 3, len_nu - 3) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_V_pot . _V_pot_noinvert $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
/* don't print Vpot - Maxima may hang */
Vpot : 1/2 * c . _V_pot . transpose(c) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
константы интегралов:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
integrals : pers3(diff(L_star, nu[s]) where [ expand ], s);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
cs(nu0, chi0) := integrals where append(real(params), pernu(nu[i] = nu0[i], i), perwheel(chi[i] = chi0[i], i));
cs3(nu30, chi0) := cs(append([0, 0], [ nu30 ], pers(0, s)), chi0);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
cs3(0, perwheel(0, i));
cs3(1, perwheel(0, i));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
производная потенциала:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
dvpot_dchi1_at_c_for_nu3_1_chis0_0: diff(Vpot, chi[1]) where append(
    real(params),
    pers(c[s] = cs3(1, perwheel(0, dontmatter))[s], s) /* nus = 0 => cs = nu3*mult */
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
dvpot_dchi1_at_c_for_nu3_1_chis0_0_at_chi(chi_vals) := float(dvpot_dchi1_at_c_for_nu3_1_chis0_0 where perwheel(chi[i] = chi_vals[i], i));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
dvpot_dchi1_at_c_for_nu3_1_chis0_0_at_all_chis : makelist(
    makelist(
        makelist(
            [ [ chi1, chi2, chi3 ], dvpot_dchi1_at_c_for_nu3_1_chis0_0_at_chi([ chi1, chi2, chi3 ]) ],
            chi3, -%pi/4, %pi/4, 0.1
        ),
        chi2, -%pi/4, %pi/4, 0.1
    ),
    chi1, -%pi/4, %pi/4, 0.1
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
потенциал на уровнях:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
VpotK(nu30, chi0) := block([consts], consts : cs3(nu30, chi0), Vpot where pers(c[s] = consts[s], s));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
VpotK_chi_eq_0_zero(nu30, chi_var) := VpotK(nu30, perwheel(0, i)) where append(
    real(params),
    perwheel(chi[i] = chi_var, i)
);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
map(print, makelist(float(VpotK_chi_eq_0_zero(1, chee)), chee, -%pi/4, %pi/4, 0.1)) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
map(print, makelist(float(VpotK_chi_eq_0_zero(2, chee)), chee, -%pi/4, %pi/4, 0.1)) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
псевдоскорости от chi на уровнях
матрица у них - диагональ по s, а над ней - три строки нулей !!
значит, скорости экипажа - нули...
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
_nus_lev_mat : _M_star_inverse . K . transpose(_V_pot_noinvert) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
for idxs in lreduce(append, pernu(pers([i, j], j), i)) do if not(_nus_lev_mat[idxs[1]][idxs[2]] = 0) then (print(idxs), print(""), print(_nus_lev_mat[idxs[1]][idxs[2]]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nus_lev(c) := float(_nus_lev_mat . c);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
float(_nus_lev_mat where append(
    real(params),
    perwheel(chi[i] = -%pi/8, i)
));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Просто явно
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
_K : submatrix(1, 2, 3, _M_star);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
free_nus_from_int : solve(transpose(_K . nu - transpose(pers(c[s], s)))[1], pers3(nu[s], s))[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
int_of_en : 1/2 * transpose(nu) . _M_star . nu $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
solve(diff(int_of_en where free_nus_from_int, nu[3]) where [ nu[1] = 0, nu[2] = 0 ], nu[3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
solve(
    perbignu(diff(int_of_en where free_nus_from_int, nu[i]), i),
    perbignu(nu[i], i)
);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Прочие изыскания
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
_M_star;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
L_star;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
integrals : pers3(diff(L_star, nu[s]) where [ expand ], s);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nus_from_integrals : pers3(nu[s] = (-diff(L_star, nu[s]) where [ expand, B = 1 ]) + nu[s] + c[s]/B, s);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
lagr_mult_fun(non_growing_C2_fun, integrals_C2, multiple_symbol, const_symbol) := 
    non_growing_C2_fun
    + sum(
        multiple_symbol[multiple_index] * (integrals_C2[multiple_index] - const_symbol[multiple_index]),
        multiple_index, 1, length(integrals_C2)
    );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
W : lagr_mult_fun(L_star, integrals, lambda, c);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
var_and_crit_eq_pairs : append(
    pernu([nu[i], diff(W, nu[i])], i),
    perwheel([chi[i], diff(W, chi[i])], i),
    pers([lambda[s], diff(W, lambda[s])], s)
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
for eq in var_and_crit_eq_pairs do (print(eq[1]), print(""), print(eq[2] = 0), print(""));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
diff(L_star, chi[2]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nu123_eqs : [ (_M_star . nu)[1][1], (_M_star . nu)[2][1], (_M_star . nu)[3][1] ];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nu123_eqs_with_ints : nu123_eqs where nus_from_integrals;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_mu_star_123 : genmatrix(lambda([i,j], diff(nu123_eqs_with_ints[i], nu[j])), 3, 3);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_mu_star_123_inverse : invert(_mu_star_123);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sumlist(perfree(sin(chi[i] + kappa[j])^2, i, j)) where append(
    real(params),
    [ trigsimp ]
);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
invert(_mu_star_123 where append(
    real(params),
    perwheel(chi[i] = chi, i),
    [ trigsimp, ratsimp ]
));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
diff(_M_star, chi[2]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
diff(L_star, nu[3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
((_M_star . nu)[3][1] - diff(L_star, nu[3])) where [ expand ];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: title   start ]
BELOW GO RANDOM INVESTIGATIONS
   [wxMaxima: title   end   ] */

/* [wxMaxima: fold    start ] */

/* [wxMaxima: input   start ] */
constraints;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
derivabbrev:false;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
(diff(L_star, nu[6]) = 0) where [
    nu[3] = Lambda * diff(theta, t),
    nu[6] = diff(phi[1,4], t),
    expand,
    B = 1,
    diff(theta, t) = d(theta),
    diff(phi[1,4], t) = d(phi[1,4])
];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sin(kappa[4] + chi[1])*phi[1,4] + theta = const;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
diff(sin(kappa[4] + chi[1])*phi[1,4] + theta = const, t);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
derivabbrev:true;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
makelist(poiz(_P[1], _P[i]), i, 4, len_nu);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
makelist(poiz(L_star, _P[i]), i, 4, len_nu);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
rest(_M_star . nu, 3) where real(params);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
ints(nu3, nuss, chis) := float(rest(_M_star . nu, 3) where append(
    real(params),
    [ nu[3] = nu3 ],
    pers3(nu[S] = nuss[S-3], S),
    perwheel(chi[I] = chis[I], I)
));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
ints(1, [2,3,4,5,6,7,8,9,10], [1,2,3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_ints(p) := block(
    [
        c: coords(p),
        nu3, nuss, chis
    ],
    
    nu3: extract_nu(3, c),
    nuss: extract_free_nus(c),
    chis: extract_chis(c),

    [time(p), ints(
        nu3, 
        nuss,
        chis
    )]

);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
load_sol("/Users/data/Yandex.Disk/work/aspa/zobova/maxima/gcp_sol/simple_with_4_rollers_t_100_diagonal_lo_def/sol.lisp", "sol") $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
matrix_series: makelist(_ints(sol[index]), index, 1, 3000) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
vector_series: map(
    [pair] -> [first(pair), makelist(scd, scd, transpose(second(pair))[1])],
    matrix_series
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
time_series: makelist(
    makelist(
        [ pair[1], pair[2][i] ], pair, vector_series
    ),
    i, 1, length(vector_series[1][2])
) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
maxima_tempdir: "~";
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
plotter : plot@windows $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
plot2d(
    map([ser] -> [discrete, ser], time_series)
);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
show(sol, "all_rollers_speeds[1]") $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: title   start ]
IMPACT -- CHECKING MAKING LOST ENERGY EQUAL TO ENERGY OF LOST VELOCITIES
   [wxMaxima: title   end   ] */

/* [wxMaxima: comment start ]
And the result of this investigation is:

     DELTA T = T DELTA ONLY WHEN CALCULATED VIA DQS BECAUSE

    IN THAT CASE THE PERMUTATION HAPPENS BEFORE COMPARISON:

    WE FIRST PERMUTE DQS, AND ONLY AFTER THAT DO WE CALCULATE OLD T,

    WHEREAS WITH NUS WE CAN'T JUST PERMUTE THEM,

    BUT HAVE TO REORDER ROWS OF _V AS WELL, WHICH IS NOT DONE IN THIS CODE,

    HENCE DELTA T(NU) INCLUDES THE (NON-EXISTENT) "LOSS" FROM NU PERMUTATION
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
nus_old : [0.9810781267190002,-0.1882641507640758,0.9995744010121401,0.0179691493540535,-0.1398784180979328,-0.0179691493540535,0.005459878868930965,0.07633482064743378,-0.005459878868930965,0.1674513405004151,-0.3994093699553674,-0.1674513405004151] $
chis_old : [-0.2521674414987675,0.1365839467338339,-0.792959329852356] $
phis_old : [1.099307629950698,0.002369228784500104,-0.02701106783209523,-0.002369228784500104,-0.6290994700043099,7.121679445691041e-4,0.01476124541932105,-7.121679445691041e-4,-0.5798325794413886,0.02025159073786547,-0.07529509385722494,-0.02025159073786547] $
xytheta : [0.05398466055359005,3.662810145103408e-4,0.2018984054705089] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
coords_before : append
    ( nus_old
    , chis_old
    , phis_old
    , xytheta
    );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
apply_impact_theory(coords_before);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
chis_new : adjust_chis(chis_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
actual : [ vars, vals ] -> ( makelist(vars[i] = vals[i], i, 1, length(vars)) );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
real_params_and_new_chis : append(
      real(params), 
      actual(perwheel(chi[i], i), chis_new),
      actual([theta], [xytheta[3]])
    );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
rly : [it] -> float(it where real_params_and_new_chis);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
coords_before;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dqs_old : transpose(
    rly(_V) . nus_old
)[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
coords : coords_before;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
renumber_phis : shift_vars(phis(), coords) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_sym_dqs_old : [ __Dx, __Dy, __Dtheta
    , __Dchi1, __Dchi2, __Dchi3
    , __Dphi1, __Dphi2, __Dphi3
    , __Dphi12, __Dphi13, __Dphi14
    , __Dphi22, __Dphi23, __Dphi24
    , __Dphi32, __Dphi33, __Dphi34
    ] ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_sym_dhpis : extract_Dphis(_sym_dqs_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
extract_all_but_Dphis(_sym_dqs_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dphis_old : extract_Dphis(Dqs_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_sym_renum_dphis : renumber_phis(_sym_dhpis);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dphis_old_shifted : renumber_phis(Dphis_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_sym_cf_phis : extract_and_put_contacting_first(_sym_renum_dphis);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dphis_old_shifted_contacting_first : extract_and_put_contacting_first(Dphis_old_shifted);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
phis_new : renumber_phis(phis_old);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dqs_old_shifted : float(append(
      extract_all_but_Dphis(Dqs_old),
      Dphis_old_shifted_contacting_first
    ));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nus_new : pernu(nu_new[i], i);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
F : concatlists(perwheel([ Fx[i], Fy[i] ], i));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K_xytheta : map(concatlists,

        [     perwheel([ 1,                       0                     ], i)

        ,     perwheel([ 0,                       1                     ], i)

        , R * perwheel([ -sin(theta + alpha[i]),  cos(theta + alpha[i]) ], i)

        ]

      );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K_chi : l * perwheel(makelist(

          /* [ -sin, cos, 0,    0,   0,    0   ] */

          /* [ 0,    0,   -sin, cos, 0,    0   ] */

          /* [ 0,    0,   0,    0,   -sin, cos ] */

          if      j = 2*i - 1 then -sin(theta + alpha[i])

          else if j = 2*i     then  cos(theta + alpha[i])

          else 0,

        j, 1, length(F)), i);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K_phi : perwheel(makelist(

          -rho(i) * (

            if      j = 2*i - 1 then cos(theta + alpha[i])

            else if j = 2*i     then sin(theta + alpha[i])

            else 0

          ),

        j, 1, length(F)), i)
;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K_rows : append(
       _K_xytheta
      

      , _K_chi

      , _K_phi

      , pers(makelist(0, i, 1, length(F)), s)

    );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_V;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K : apply¦¦¦¦(matrix, _K_rows);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
_K . F;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__eqs_matrix : rly(_M) . rly(_V) . transpose(nus_new) - rly(_K) . transpose(F) - rly(_M) . transpose(Dqs_old_shifted);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__eqs : transpose(__eqs_matrix)[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
append(nus_new, F);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
impact_sol : float(map(second, solve(__eqs, append(nus_new, F))[1]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
    nus_new : pernu(impact_sol[i], i);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
    __kin_en : [v_list] -> (
      /* imlog@info("v_list =", rly(v_list)), */
      rly(1/2 * rly(v_list) . rly(_M) . transpose(rly(v_list)))
    );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__T_old_Dq : __kin_en(Dqs_old_shifted);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__T_old_nu : __kin_en((nus_old . transpose(_V))[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__T_new : __kin_en((nus_new . transpose(_V))[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__T_new - __T_old_Dq;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
-__kin_en(transpose(rly(_V) . nus_new)[1] - Dqs_old_shifted);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
__T_new - __T_old_nu;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
-__kin_en(transpose(rly(_V) . (nus_new - nus_old))[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dqs_old_shifted;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dqs_old_via_nus : (rly(nus_old . transpose(_V)))[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
Dqs_old_via_nus - Dqs_old_shifted;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sdot(metric_matrix) := buildq([metric_matrix], lambda([a_list, b_list], a_list . metric_matrix . transpose(b_list)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
mdot : sdot(rly(_M)) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
mdot(rly(_V) . transpose(nus_new), rly(_V) . transpose(nus_new) - Dqs_old_shifted);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Obtain nus_new by projecting Dq- onto the subspace based on _V orthogonally in kinetic metric (wrt M)
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
get_col(idx, mat) := apply(submatrix, cons(mat, append(makelist(i, i, 1, idx - 1), makelist(i, i, idx + 1, length(mat[1]))))) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sqmnorm(vec) := mdot(vec, vec) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nus_new;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
nus_ort : transpose(invert(transpose(rly(_V)) . rly(_M) . rly(_V)) . (transpose(rly(_V)) . rly(_M) . transpose(Dqs_old_shifted)))[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sqrt((nus_ort - nus_new) . transpose(nus_ort - nus_new));
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
